1. Data Hiding:
	Out side person can't access our internal data directly or our data should not go out directly. This OOP feature is nothing but data hiding.
	After validation/authentication out side person can access our internal data.
	Example 1:
		After providing proper userName/password we can able to access our gmail inbox information.

	Example 2:
		Even tho we are valid customer of the bank we can able to access our account information and we can't access others account information.

	By declaring data member (variable) as private we can achieve data hiding
	Example:
		public class Account {
			private double balance;
			public double getBalance() {
				// Validation
				return balance;
			}
		}

	The main advantage of data hiding is security.

	Note: It's highly recommended to declare data member (variable) as private.

2. Abstraction:
	Hiding internal implementation and just highlight the set of services what we are offering is the concept of abstraction.
	Example:
		Through bank ATM GUI screen bank people are highlighting the set of services what they are offering without highlighting internal
		implementation.

	The main advantages of abstraction are
		1. We can achieve security because we are not highlighting our internal implementation.
		2. Without affecting outside person we can able to perform any type of changes in our internal system. Enhancement will become easy.
		3. It improves maintainability of the application.
		4. It improves easiness to use our system.

	By using interfaces and abstract classes we can implement abstraction.

3. Encapsulation:
	The process of binding data & corresponding methods into a single unit is nothing but encapsulation.
	Example:
		class Student {
			data member + methods (behaviour)
		}

	If any component follows the data hiding & abstraction such type of component is said to be encapsulated component.
	Encapsulation = data hiding + abstraction

	Example:
		public class Account {
			private double balance;
			public double getBalance() {
				// Validation
				return balance;
			}
			public void setBalance(double balance) {
				// Validation
				this.balance = balance;
			}
		}

		GUI -> Balance Enquiry, Update Balance

	The main advantages of encapsulation are
	1. We can achieve security
	2. Enhancement will become easy
	3. It improves maintainability of the application

	The main advantage of encapsulation is we can achieve security but the main disadvantage of encapsulation is it increases length of the code
	and slows down execution.

4. Tightly Encapsulated Class:
	A class is said to be tightly encapsulated if and only if each and every variable declare as private. Whether class contains corresponding getter
	& setter methods or not. and whether these methods are declared as public or not. These things we are not required to check.
	Example:
		public class Account {
			private double balance;
			public double getBalance() {
				return balance;
			}
		}

	Q. Which of the following are tightly encapsulated?
	class A {
		private int x = 10;			// Yes
	}
	class B extends A {
		int y = 20;				// No
	}
	class C extends A {
		private int z = 30;			// Yes
	}

	Q. Which of the following classes are tightly encapsulated?
	class A {
		int x = 10;				// No
	}
	class B extends A {
		private int y = 20;			// No
	}
	class C extends B {
		private int z = 30;			// No
	}

	Note: If the parent class is not tightly encapsulated then no child class is tightly encapsulated.

5. Is-A Relationship:
	It's a also know as inheritance.
	That main advantage of Is-A relationship is code reusability.
	By using extends keyword we can implement Is-A relationship.

	Example:
		class P {
			public void m1() {
				System.out.println("Parent");
			}
		}
		class C extends P {
			public void m2() {
				System.out.println("Child");
			}
		}
		class Test {
			public static void main(String[] args) {
				P p = new P();
				p.m1();			// Output: Parent
				p.m2();			// CTE -> error: cannot find symbol

				C c = new C();
				c.m1();			// Output: Parent
				c.m2();			// Output: Child

				P p1 = new C();
				p1.m1();		// Output: Parent
				p1.m2();		// CTE -> error: cannot find symbol

				C c1 = new P();	// CTE -> error: incompatible types: P cannot be converted to C
			}
		}

	Conclusion:
		1. What ever method parent has by default to the child. Hence child reference we can call parent and child class method.
		2. What ever methods child has by default not available to parent. Hence on the parent reference we can't call child specific methods.
		3. Parent reference can be used to hold child object but by using that reference we can't call child specific methods but we can call the
		methods present in parent class.
		4. Parent reference can be used to hold child object but child reference can't be used to hold parent object.

		Example:
			Without Inheritance
			class VLone {
				300 Methods;
			}
			class HLone {
				300 Methods;
			}
			class PLone {
				300 Methods;
			}

			With Inheritance
			class Loan {
				250 Common Methods;
			}
			class VLoan extends Loan {
				50 Specific Methods;
			}
			class HLone extends Loan {
				50 Specific Methods;
			}
			class PLoan extends Loan {
				50 Specific Methods;
			}

		Note: The most common methods which are applicable for any type of child, we have to define in parent class. The specific methods which are
		applicable for a particular child we have to define in child class.

	Total Java API is implemented based on inheritance concept.
	The most common methods which are applicable for any java object are defined in object class. Hence every class in java ia the child class of
	object either directly or indirectly. So that object class method by default available to every java class without rewriting. Due to this object
	class access root for all java classes.

	Throwable class defines the most common methods which are required for every exception & error classes. Hence this class access root for java
	exception hierarchy.

	Multiple inheritance:
		A java class can't extend more than one class at a time. Hence java won't provide support for multiple inheritance in classes.
		Example:
			class A extends B, C {} // CTE

	Note: If our class doesn't extend any other class then only our class is direct child class of object.
		Example:
			class A {} // A is a child of object

		If our class extend any other class then our class is indirect child class of object

			class B extends A {} // B is child of object of class A and A is child of Object class
			it's multi level inheritance but not multiple inheritance.

		Either directly or indirectly java won't provide support for inheritance wrt classes.

	Why java won't provide support for multiple inheritance?
	There may be a chance of ambiguity problem hence java won't provide support for multiple inheritance.
	class C extends P1, P2

	But interface can extend any no of interfaces simultaneously. Hence java provide support for multiple inheritance wrt interfaces.
	Example:
		interface A {}
		interface B {}
		interface C extends A, B {}

	Why ambiguity problem won't be there in interfaces:
		P1I1 -> m1(), P2I2 -> m1()
		CI -> m1()
		class c implements CI, P1I1, P2I2 {
			m1() {}
		}

	Even tho multiple method declarations are available but implementation is unique. Hence there is no chance of ambiguity problem in interfaces

	Note: Strictly speaking through interfaces we won't get any inheritance.

	Cyclic inheritance:
		Cyclic inheritance is not allowed in java. Of course it's not required
		Example:
			class A extends A {}	// CTE -> cyclic inheritance involving A

			class A extends B {}	// CTE -> cyclic inheritance involving A
			class B extends A {}

6. Has-A Relationship:
	Has-A relationship is also known as composition or aggregation.
	There is no specific keyword to implement Has-A a relation but most of the time we are depending on new keyword.
	The main advantage of Has-A relationship is reusability of the code.
	Example:
		class Engine {
			// Engine specific functionality
		}

		class Car {
			Engine e = new Engine()
		}
		Car Has-A a Engine reference

	Difference between composition & aggregation:
		Composition:
			Without existing container object if there is no chance of existing contented object then container & contented objects are strongly
			associated and this strong association is nothing but composition.

			Example:
				University consist of several departments without existing university there is no chance of existing department. Hence university
				and	department are strongly associated and this strong association is nothing but composition.

		Aggregation:
			Without existing container object if there is a chance of existing contented object then container & contented objects are weekly
			associated and this week association is nothing but aggregation.

			Example:
				Department consist of several professors. Without existing department there may be chance of existing professors objects. Hence
				department and professors objects are weekly associated and this week association is nothing but aggregation.

	Note:
		In composition objects are strongly associated where as in aggregation objects are weekly associated.
		In composition container object holds directly contented objects where as in aggregation container object holds just references of contented
		objects.

	Is-A vs Has-A:
		If we want total functionality of a class automatically then we should go for Is-A relationship.
		Example:
			Person - Student : Complete functionality required of person in student

		If we want part of the functionality then we should go for Has-A relationship.
		Example:
			class Test {100 method}
			class Demo {
				Test t = new Test();
				t.m1();
				t.m6();
				t.m99();
			}

7. Method Signature:
	In java method signature consist of method names followed by argument types.
	Example:
		public static int m1(int i, float f);

		m1(int, float): method signature

	Return type is not part of method signature is java.
	Compiler will use method signature to resolve method calls.
	Example:
		class Test {
			public void m1(int i) {}
			public void m2(String s) {}
			public static void main(String[] args) {
				Test t = new Test();
				t.m1(10);
				t.m2("Hello");
				t.m3(10.5);		// CTE -> error: cannot find symbol. symbol:   method m3(double), location: variable t of type Test
			}
		}

	Within a class two method with the same signature not allowed.
	Example:
		class Test {
			public void m1(int i) {}
			public int m1(int x) {		// CTE -> error: method m1(int) is already defined in class Test
				return 10;
			}
			public static void main(String[] args) {
				Test t = new Test();
				t.m1(10);
				t.m1(10);
			}
		}

8. Overloading:
	Two method said to be overloaded if and only if both methods having same name but different argument types.

	In C language method overloading concept is not available. Hence we can't declare multiple methods with the same name but different argument
	types. If there is a change in argument type compulsory we should go for new method name. Which increases complexity of programming.

	But in java we can declare multiple methods with same name but different argument types. Such type of methods are called overloaded method.
	Example:
		abs(int i), abs(long l), abs(float f)

	Having overloading concept in java reduces complexity of programming.
	Example:
		class Test {
			public void m1() {
				System.out.println("No-Arg method");
			}
			public void m1(int x) {
				System.out.println("int-Arg method");
			}
			public void m1(double d) {
				System.out.println("double-Arg method");
			}
			public static void main(String[] args) {
				Test t = new Test();
				t.m1();				// Output: No-Arg method
				t.m1(10);			// Output: int-Arg method
				t.m1(10.5);			// Output: double-Arg method
			}
		}

	* In overloading method resolution always takes care by compiler based on reference type. Hence overloading is also consider as compile time
		polymorphism, static binding, early binding.

	Case 1:
		Automatic promotion in overloading
			1. while resolving overloaded methods if exact matched method is not available then we won't get any compile time error immediately.
			First it'll promote argument to the next level and check where matched method is available or not. If matched method is available then
			it'll be considered. If matched method is not available then compiler promote argument once again to the next level. This process will
			be continued until all possible promotions. Still if the matched method is not available then we'll get CTE.
			The following are all possible promotions in overloading.
			Example:
				byte - short - int - long - float - double
				char - int - long - float - double

			This process is called automatic promotion in overloading.

			class Test {
				public void m1(int x) {
					System.out.println("int-Arg method");
				}
				public void m1(float f) {
					System.out.println("float-Arg method");
				}
				public static void main(String[] args) {
					Test t = new Test();
					t.m1(10);		// Output: int-Arg method
					t.m1(10.5f);		// Output: float-Arg method
					t.m1('a');		// Output: int-Arg method
					t.m1(10l);		// Output: float-Arg method
					t.m1(10.5);		// CTE -> error: no suitable method found for m1(double)
				}
			}

	Case 2:
		class Test {
			public void m1(String s) {
				System.out.println("String version");
			}
			public void m1(Object o) {
				System.out.println("Object version");
			}
			public static void main(String[] args) {
				Test t = new Test();
				t.m1(new Object());		// Output: Object version
				t.m1("Test");			// Output: String version
				t.m1(null);			// Output: String version
			}
		}

		While resolving overloaded method compiler will always gives the precedence to child type argument when compared with parent type argument.

	Case 3:
		class Test {
			public void m1(String s) {
				System.out.println("String version");
			}
			public void m1(StringBuffer sb) {
				System.out.println("StringBuffer version");
			}
			public static void main(String[] args) {
				Test t = new Test();
				t.m1("Test");				// Output: String version
				t.m1(new StringBuffer("Test"));		// Output: StringBuffer version
				t.m1(null);				// Output: CTE -> error: reference to m1 is ambiguous
			}
		}

	Case 4:
		class Test {
			public void m1(int i, float f) {
				System.out.println("int-float version");
			}
			public void m1(float f, int i) {
				System.out.println("float-int version");
			}
			public static void main(String[] args) {
				Test t = new Test();
				t.m1(10, 10.5f);	// Output: int-float version
				t.m1(10.5f, 10);	// Output: float-int version
				t.m1(10, 10);		// Output: error: reference to m1 is ambiguous
				t.m1(10.5f, 10.5f);	// Output: error: no suitable method found for m1(float,float)
			}
		}

	Case 5:
		class Test {
			public void m1(int i) {
				System.out.println("General Method");
			}
			public void m1(int... i) {
				System.out.println("Var-Args Method");
			}
			public static void main(String[] args) {
				Test t = new Test();
				t.m1();			// Output: Var-Args Method
				t.m1(10, 20);		// Output: Var-Args Method
				t.m1(10);		// Output: General Method
			}
		}

		In general Var-Args method will get least priority. That's if no other method matched then only Var-Args method will get the chance. It's
		exactly same as default case inside switch.

	Case 6:
		class Animal {}
		class Monkey extends Animal {}

		class Test {
			public void m1(Animal a) {
				System.out.println("Animal version");
			}
			public void m1(Monkey m) {
				System.out.println("Monkey version");
			}
			public static void main(String[] args) {
				Test t = new Test();
				Animal a = new Animal();
				t.m1(a);				// Output: Animal version
				Monkey m = new Monkey();
				t.m1(m);				// Output: Monkey version
				Animal a1 = new Monkey();
				t.m1(a1);				// Output: Animal version
			}
		}

		Note:
			In overloading method resolution always takes care by compiler based on reference type.
			In overloading runtime object won't play any role.

9. Overriding:
	Whatever methods parent has by default available to the child through inheritance. If child class not satisfied with parent class implementation
	then child is allowed to redefine that method based on it's requirement. This process is called Overriding.
	The parent class method which is overridden is called overridden method and child class method which is overriding is called Overriding method.
	Example:
		class P {
			public void property() {
				System.out.println("Cash + Land + Gold");
			}
			public void marry() {
				System.out.println("Laxmi");
			}
		}
		class C extends P {
			public void marry() {
				System.out.println("3Sha|4Me|9Tara");
			}
		}
		class Test {
			public static void main(String[] args) {
				Test t = new Test();
				P p = new P();
				p.marry();			// Output: Laxmi
				C c = new C();
				c.marry();			// Output: 3Sha|4Me|9Tara
				P p1 = new C();
				p1.marry();			// Output: 3Sha|4Me|9Tara
			}
		}

	* In Overriding method resolution always takes care by JVM based on runtime object and hence overriding is also considered as runtime
	polymorphism or dynamic polymorphism or late binding.

	Rules for Overriding:
		1. In Overriding, methods name & argument types must be matched that's method signatures must be same.

		2. In Overriding, return type must be same but this rule is applicable only until 1.4 version only. From 1.5 version onwards we can take
			Co-Variant types. According to this child class method return type need not be same as parent method return type. It's child type also
			allowed.
			Example:
				class P {
					public Object m1() {
						return null;
					}
				}
				class C extends P {
					public String m1() {
						return null;
					}
				}

			It's invalid in 1.4 version but from 1.5 version it's valid.

Parent class method return type:	Object				Number		String		double

Child class method return type: 	Object|String|StringBuffer	Number|Integer	String		int - not possible - CTE

			Co-Variant return type concept applicable only fro Object types but not for primitive types

		3. Parent class private methods not available to the child. Hence Overriding concept not applicable for private methods.
			Based on our requirement we can define exactly same private method in child class it's valid but not overriding.
			Example:
				class P {
					private void m1() {}
				}
				class C extends P {
					private void m1() {}	// It's valid but not overriding
				}

		4. We can't override parent class final method in child class. If we are trying to override we'll get CTE.
			Example:
				class P {
					public final void m1() {}	// CTE -> error: m1() in C cannot override m1() in P
				}
				class C extends P {
					public void m1() {}
				}

		5. Parent class abstract method we should override in child class to provide implementation.
			Example:
				abstract class P {
					public abstract void m1();
				}
				class C extends P {
					public abstract void m1() {}
				}

		6. We can override non-abstract method as abstract.
			Example:
				class P {
					public void m1(){}
				}
				abstract class C extends P {
					public abstract void m1();
				}

			The main advantage of this approach is we can stop the availability of parent method implementation to the next level child classes.

		7. In overriding the following modifiers won't keep any restriction.
			1. synchronized
			2. native
			3. strictfp
			4. abstract

parent method	final			non-final	abstract		synchronized		native			strictfp
		not			possible	both possible		both possible		both possible		both possible
child method  	non-final		final		non-abstract		non-synchronized	non-native		non-strictfp

		8. While overriding we can't reduce scope of access modifier. But we can increase the scope.
			Example:
				class P {
					public void m1(){}
				}
				class C extends P {
					void m1() {}		// CTE -> error: m1() in C cannot override m1() in P
								// attempting to assign weaker access privileges; was public
				}

				class P {
					void m1(){}
				}
				class C extends P {
					public void m1() {}	// possible
				}

		private < default < protected < public
Parent class method:	public		protected				default							private

Child class method :	public		protected|public		default|protected|public		overloading concept not applicable for private

		9. If child class method throws any checked exception compulsory parent class method should throw the same checked exception or it's parent
		otherwise we'll get CTE. But there are no restriction for unchecked exception.
		Example:
			import java.io.*;
			class P {
				public void m1() throws IOException {}
			}
			class C extends P {
				public void m1() throws EOFException, InterruptedException {}
			}
		CTE  -> error: m1() in C cannot override m1() in P, overridden method does not throw java.lang.InterruptedException

	Which of the followings are valid

	1.
		P: public void m1() throws Exception
		C: public void m1()

	2.
		P: public void m1()
		C: public void m1() throws Exception

	3.
		P: public void m1() throws Exception
		C: public void m1() throws IOException

	4.
		P: public void m1() throws IOException
		C: public void m1() throws Exception

	5.
		P: public void m1() throws IOException
		C: public void m1() throws FileNotFoundException, EOFException

	6.
		P: public void m1() throws IOException
		C: public void m1() throws EOFException, InterruptedException

	7.
		P: public void m1() throws IOException
		C: public void m1() throws ArithmeticException, NullPointerException, ClassCastException

	Ans.
		1. Valid
		2. Invalid
		3. Valid
		4. Invalid
		5. Valid
		6. Invalid
		7. Valid

	import java.io.IOException;
	class P {
		public void m1() throws IOException {}
	}
	class C extends P {
		public void m1() throws IOException {}
	}
	class Test {
		public static void main(String[] args) {
			try {
				P p = new C();
				p.m1();
			} catch(IOException e) {
				e.printStackTrace();
			}

		}
	}
	valid

	Overriding WRT static methods:
		We can't override a static method as non-static otherwise we'll get CTE.
		Example:
			class P {
				public static void m1() {}
			}
			class C extends P {
				public void m1() {}		// CTE ->  error: m1() in C cannot override m1() in P, overridden method is static
			}

			class P {
				public void m1() {}
			}
			class C extends P {
				public static void m1() {}	// CTE -> error: m1() in C cannot override m1() in P, overriding method is static
			}

		If both Parent and Child class methods are static then we won't get any CTE. It seams overriding concept applicable for static methods.
		But it's not overriding and it' s method hiding.
		Example:
			class P {
				public static void m1() {}
			}
			class C extends P {
				public static void m1() {}
			}

	Method Hiding:
		All rules of method hiding is exactly same as overriding except the following differences
		Example:
			class P {
				public static void m1() {
					System.out.println("Parent");
				}
			}
			class C extends P {
				public static void m1() {
					System.out.println("Child");
				}
			}
			class Test {
				public static void main(String[] args) {
					P p = new P();
					p.m1();				// Output: Parent
					C c = new C();
					c.m1();				// Output: Child
					P p1 = new C();
					p1.m1();			// Output: Parent
				}
			}
________________________________________________________________________________________________________________________________________________________
			Method Hiding					|				Overriding					|
------------------------------------------------------------------------|-------------------------------------------------------------------------------|
1. Both Parent and Child class method should be static.			|1. Both Parent and Child class method should be non-static.			|
2. Compiler is responsible for method resolution based of reference	|2. JVM is always responsible for method resolution based of runtime object.	|
 type.									|										|
3. It's also known as Compile time Polymorphism, Static Polymorphism,	|3. It's also known as Runtime Polymorphism, Dynamic Polymorphism, Late	Binding.|
 Early Binding.								|										|
--------------------------------------------------------------------------------------------------------------------------------------------------------|

	Overriding WRT Var-Args Methods:
		We can override Var-Args method with another Var-Args method only. If we are trying to override with normal method then it'll become
		overloading but not overriding.
		Example: Overloading
			class P {
				public void m1(int... x) {
					System.out.println("Parent");
				}
			}
			class C extends P {
				public void m1(int x) {
					System.out.println("Child");
				}
			}
			class Test {
				public static void main(String[] args) {
					P p = new P();
					p.m1(10);				// Output: Parent
					C c = new C();
					c.m1(10);				// Output: Child
					P p1 = new C();
					p1.m1(10);				// Output: Parent
				}
			}

		In the above program if we will replace child method with Var-Args method then it'll become overriding. In this case the output is
		Example: Overriding
			class P {
				public void m1(int... x) {
					System.out.println("Parent");
				}
			}
			class C extends P {
				public void m1(int... x) {
					System.out.println("Child");
				}
			}
			class Test {
				public static void main(String[] args) {
					P p = new P();
					p.m1(10);				// Output: Parent
					C c = new C();
					c.m1(10);				// Output: Child
					P p1 = new C();
					p1.m1(10);				// Output: Child
				}
			}
	Overriding WRT variables:
		Variable resolution always takes care by compiler based on reference type irrespective of whether the variable is static or non-static.
		(overriding concept applicable only for method but not for variables).
		Example:
			class P {
				int x = 888;
			}
			class C extends P {
				int x = 999;
			}
			class Test {
				public static void main(String[] args) {
					P p = new P();
					System.out.println(p.x);		// Output: 888
					C c = new C();
					System.out.println(c.x);		// Output: 999
					P p1 = new C();
					System.out.println(p1.x);		// Output: 888
				}
			}
________________________________________________________________________________________________
P	|	non-static	|	static		|	non-static	|	static	|
C	|	non-static	|	non-static	|	static		|	static	|
--------|-----------------------------------------------|-----------------------|---------------|
	|	888		|	888		|	888		|	888	|
	|	999		|	999		|	999		|	999	|
	|	888		|	888		|	888		|	888	|
------------------------------------------------------------------------------------------------|

Difference between Overloading and Overriding:
________________________________________________________________________________________________________________________________________________________
Property			|	Overloading			|		Overriding							|
--------------------------------|---------------------------------------|-------------------------------------------------------------------------------|
1. Method Name			| Must be same.				| Must be same.									|
2. Argument Types		| Must be different (at lease order).	| Must be different (including order).						|
3. Method Signature		| Must be different.			| Must be same.									|
4. Return Types			| No Restriction.			| Must be same until 1.4 but from 1.5 version onwards Co-Variant also allowed.	|
5. private, static, final	| Can be overloaded.			| can't be overridden.								|
6. Access Modifier		| No restriction.			| We can't reduce scope of access modifier but we can increase the scope.	|
7. throws clause		| No restriction.			| If child class method throws any checked exception compulsory parent class	|
				|					| method should throw same or parent but no restriction for unchecked exception.|
8. Method resolution		| Always takes care by compiler 	| Always takes care by JVM based on runtime object.				|
				| based on reference type.		|										|
9. It's also known as		| CTP|SP|Early binding.			| RTP|DP|Late binding.								|
---------------------------------------------------------------------------------------------------------------------------------------------------------
Note:
	In Overloading we have to checked only method names (must be same) and argument types (must be different). We are not required to check
	remaining like return types, access modifier etc.

	In Overriding everything we have to check like method name, argument types, return type, access modifier, throws clause etc.

	Consider the following method in parent class.
		public void m1(int x) throws IOException

	In the child class which of the following method we can take
		1. public void m1(int i)			// Overriding
		2. public static int m1(long l)			// Overloading
		3. public static void m1(int i)			// Overriding Invalid
		4. public void m1(int i) throws Exception	// Overriding Invalid
		5. public static abstract void m1(double d)	// Overloading Illegal combination of modifiers 'abstract' and 'static'

	Polymorphism:
		One name but multiple forms is a concept of Polymorphism.
		Example 1:
			Method name is the same but we can apply for different types of arguments (Method Overloading).
			abs(int)
			abs(long)
			abs(float)

		Example 2:
			Method signature is same but in parent class one type of implementation and in the child class another type of implementation (Overriding)
			class P {
				marry() {}
			}
			class C extends P {
				marry() {}
			}
		Example 3:
			Uses of Parent reference to hold child object is the concept of Polymorphism.
			List l = new ArrayList();
				l = new LinkedList();
				l = new Stack();
				l = new Vector()

		Parent class reference can be used to hold child object but by using that reference we can call only the methods available in parent class.
		And we can't call child specific methods.
		Example:
			P -> m1();
			C -> m2();

			P p = new C();
			p.m1();
			p.m2(); // can't find symbol, symbol method m2(), location: class P

		But by using child reference we can call both parent and child class methods.
			C c = new C();
			c.m1();
			c.m2();

	Q. When we should go for Parent reference to hold Child object?
	Ans. If we don't know exact runtime type of object then we should go for Parent reference.
		for example: the first element present in the ArrayList can be any type. It may be Student object, Customer object, String, StringBuffer.
		Hence the return type of get method is Object, which can hold any object.
		Example: Object o = l.get(0);

________________________________________________________________________________________________________________________________________________________
	C c = new C();							|			P p = new P();						|
	ArrayList al = new ArrayList()					|			List l = new ArrayList()				|
------------------------------------------------------------------------|-------------------------------------------------------------------------------|
1. We can use this approach if we know exact runtime of object.		|1. We can use this approach if we don't know exact runtime type of object.	|
2. By using child reference we can call both parent & child methods	|2. By using parent reference we can call only methods available in parent class|
 (this is the advantage of this approach).				| and we can't call child specific methods (this is the disadvantage of it).	|
3. We can use child reference to hold only particular child class	|3. We can use parent reference to hold any child class object. (this is the	|
 object (this is the disadvantage of this approach).			| advantage of this approach).							|
--------------------------------------------------------------------------------------------------------------------------------------------------------|

	Pillars of OOP
	Encapsulation	-	Security
	Inheritance	- 	Reusability
	Polymorphism	-	Flexibility

					Polymorphism
					    /\
					   /  \
					  /    \
					 /      \
					/	 \
				    Static	Dynamic
				Compile-time 	Runtime
				Early Binding	Late Binding
				     /\			|
		  		    /  \		|
		  		   /    \		|
		 		  /      \		Overriding
				 /        \
			Overloading	Method Hiding

	Beautiful definition of Polymorphism:
		A BOY starts LOVE with the work FRIENDSHIP, but GIRL ends LOVE with the same word FRIENDSHIP. Word is the same but attitude is different.
		This beautiful concept of OOPS is nothing but polymorphism.

13. Coupling:
		The degree of the dependency between the component is call coupling.
		If dependency is more then it's consider as tightly coupling and if dependency is less then it's considered as loosely coupling.

		Example:
			class A {
				static int i = B.j;
			}
			class B {
				static int j = C.k;
			}
			class C {
				static int k = D.m1();
			}
			class D {
				public static int m1() {
					return 10;
				}
			}
			class Test {
				public static void main(String[] args) {
					System.out.println(new A().i);
				}
			}

		The above component said to be tightly coupled with each-other because dependency between the component is more.
		Tightly coupling is not a good programming practice because it has several serious disadvantages.
		1. Without effecting remaining components we can't modify any component. Hence enhancement will become difficult.
		2. It suppresses readability
		3. It reduces maintainability of the application

		Hence we have to maintain dependency between the components as less as possible. That's loosely coupling is good programming practice.

14. Cohesion:
		For every component a clear well define functionality is defined then that component is said to be follow high cohesion.
		low cohesion: every thing define in single unit like TotalServlet hold login, validation, inbox, send, reply, error etc.
		high cohesion: every thing define in a separate module. Best example is MVC. login.jsp, error.jsp, validation.servlet, reply.jsp

		High cohesion is always good programming practice because it has several advantages.
			1. Without affecting remaining components we can modify any component. Hence enhancement will become easy.
			2. It promotes reusability of the code (Where ever validation required we can reuse the same validate servlet without rewriting).
			3. It improves maintainability of the application.

		Note: Loosely coupling & High cohesion are good programming practices.

15. Object Type-Casting:
		We can use parent reference to hold child object.
		Example:
			Object o = new String("Test");

		We can use interface reference to hold implemented class object
		Example:
			Runnable r = new Thread();

		Syntax:
			A b = (C) d;
			A: Class or Interface Name
			b: Nave of reference Name
			C: Class or Interface Name
			d: reference variable name

		Rule:
			1. Compile Time checking:
				The type of 'd' and 'C' must have some relation. Either child to parent or parent to child or same type. Otherwise we'll get CTE
				saying inconvertible types found d type required C

				Example 1:
					Object o = new String("Test");
					StringBuffer sb = (StringBuffer) o;

				Example 2:
					String s = new String("Test");
					StringBuffer sb1 = (StringBuffer) s;	// CTE -> error: incompatible types: String cannot be converted to StringBuffer

			2. Compile Time checking:
				'C' must be either same of derived type of 'A' otherwise we'll get CTE saying incompatible types found C required A.

				Example 1:
					Object o = new String("Test");
					StringBuffer sb = (StringBuffer) o;

				Example 2:
					String s = new String("Test");
					StringBuffer sb1 = (String) s;	// CTE -> error: incompatible types: String cannot be converted to StringBuffer

			3. Runtime Checking:
				Runtime object type 'd' must be either same or derived type of 'C'. Otherwise we'll get RTE saying ClassCastException.

				Example 1:
					Object o = new String("Test");
					StringBuffer sb = (StringBuffer) o; // RTE -> java.lang.ClassCastException: class String cannot be cast to class StringBuffer

				Example 2:
					Object o = new String("Test");
					Object sb = (String) o;				// Valid

	Strictly speaking through type casting we are not creating any new object. For the existing object we are providing another type of reference
	variable. That's we are performing type casting but not object casting.
	Example:
		String s = new String("Test");
		Object o = (Object)s;
				or
		Object o = new String("Test");

	Example:
		Integer i = new Integer(10);
		Number n = (Integer)i;
		Object o = (Object)n;
				or
		Object o = new Integer(10);

		A
		|
		B
		|
		C

		C c = new C();
		(B)c or B b = new C();
		(A)((B)c) or A a = new C();

	Example 1:
		P - m1() {}
		|
		C - m2() {}

		C c = new C();
		c.m1();		// Valid
		c.m2();		// Valid
		((P)c).m1();	// Valid
		((P)c).m2();	// Invalid

	Reason: Parent reference can be used to hold child object. But by using that reference we can't call child specific methods. And we can call
		only methods available in parent class.

	Example 2:
		A - m1() {Sop("A")}
		|
		B - m1() {Sop("B")}
		|
		C - m1() {Sop("C")}

		C c = new C();
		c.m1();
		((B)c).m1();
		((A)((B)c)).m1();
	It's Overriding and method resolution is always based on runtime object type.

		A - static m1() {Sop("A")}
		|
		B - static m1() {Sop("B")}
		|
		C - static m1() {Sop("C")}

		C c = new C();
		c.m1();
		((B)c).m1();
		((A)((B)c)).m1();


	Example 1:
		class A {
			void m1 () {
				System.out.println("A");
			}
		}
		class B extends A {
			void m1 () {
				System.out.println("B");
			}
		}
		class C extends B {
			void m1 () {
				System.out.println("C");
			}
		}

		class Test {
			public static void main(String[] args) {
				C c = new C();
				c.m1();			// Output: C
				((B)c).m1();		// Output: C
				((A)((B)c)).m1();	// Output: C
			}
		}
	It's Overriding and method resolution is always based on runtime object type.

	Example 2:
		class A {
			static void m1 () {
				System.out.println("A");
			}
		}
		class B extends A {
			static void m1 () {
				System.out.println("B");
			}
		}
		class C extends B {
			static void m1 () {
				System.out.println("C");
			}
		}

		class Test {
			public static void main(String[] args) {
				C c = new C();
				c.m1();			// Output: C
				((B)c).m1();		// Output: B
				((A)((B)c)).m1();	// Output: A
			}
		}

	It's method hiding and method resolution is always based on reference type.

	Example 3:
		class A {
			int x = 777;
		}
		class B extends A {
			int x = 888;
		}
		class C extends B {
			int x = 999;
		}

		class Test {
			public static void main(String[] args) {
				C c = new C();
				System.out.println(c.x);
				System.out.println(((B)c).x);
				System.out.println(((A)((B)c)).x);
			}
		}

	Variable resolution is always based on reference type but not based on runtime object.

10. Static Control Flow:
		When ever we are executing a java class the following sequence of steps will be executed as the part or static control flow.
		1. Identification of static members from top to bottom.
		2. Execution of static variable assign and static block from top to bottom
		3. Execution of main method.
		Example:
			class Test {
				static int i = 10;
				static {
					m1();
					System.out.println("First Static Block");
				}
				public static void main(String[] args) {
					m1();
					System.out.println("main method");
				}
				public static void m1() {
					System.out.println(j);
				}
				static {
					System.out.println("Second Static Block");
				}
				static int j = 20;
			}

		Output: 0
			First Static Block
			Second Static Block
			20
			main method

	Read Indirectly Write Only (RIWO):
		Inside static block if we are trying to read a variable that read operation is called direct read.
		If we are calling a method and within that method if we are trying to read a variable that read operation is called Indirect read
		Example:
			class Test {
				static int i = 10;
				static {
					m1();
					System.out.println(i);		// Direct read
				}
				public static void m1() {
					System.out.println(i);		// Indirect read
				}
			}

		If a variable is just identified by the JVM and original value not yet assigned then the variable is said to be in read indirectly and
		write only state (RIWO).
		If a variable is in RIWO state then we can't perform direct read but we can perform indirect read.
		If we are trying to read directly then we'll get CTE saying Illegal forward reference.
		Example:
			class Test {
				static int x = 10;
				static {
					System.out.println(x);		// Direct read	// Output: 10, RTE -> NoSuchMethodError: main
				}
			}
			class Test {
				static {
					System.out.println(x);		// Direct read	// CTE -> error: illegal forward reference
				}
				static int x = 10;
			}
			class Test {
				static {
					m1();
				}
				public static void m1() {
					System.out.println(x);		// Indirect read	// Output: 0, RTE -> NoSuchMethodError: main
				}
				static int x = 10;
			}

	Static Block:
		static block will be executed at the time of class loading. Hence at the time of class loading if we want to perform any activity, we have
		to define that inside static block.
		Example 1:
			At the time of java class loading the corresponding native library should be loaded. Hence we have to define this activity inside static
			block.
			class Test {
				static {
					System.loadLibrary("native library path");
				}
			}

		Example 2:
			After loading every DB driver class we have to register driver class with Driver Manger but inside DB Driver class there is a static
			block to perform this activity and we are not responsible to register explicitly.

			class DbDriver {
				static {
					Register this driver with DriverManager;
				}
			}

		Within a class we can declare any no of static blocks but all this static blocks will be executed from top to bottom.

		Q. Without writing main method, is it possible to print some statements to the console?
		Ans. Yes, by using static block.

		Example:
			class Test {
				static {
					System.loadLibrary("Hello I can print");
					System.exit(0);
				}
			}
		Output: Hello I can print

		Q. Without writing main method and static block is it possible to print some statements to the console?
		Ans. Yes, Of course, there are multiple ways.

		class Test {
			static int x = m1();
			public static int m1() {
				System.out.println("Hello I am print");
				System.exit(0);
				return 10;
			}
		}
		class Test {
			static Test t = new Test();
			{
				System.out.println("Hello I can print");
				System.exit(0);
			}
		}
		class Test {
			static Test t = new Test();
			Test () {
				System.out.println("Hello I can print");
				System.exit(0);
			}
		}

	Note:
		From 1.7 version onwards main method mandatory to start a problem execution. Hence from 1.7 Version onwards without writing main method
		it's impossible to print some statements to the console.

	Static control flow in parent to child relationship:
		Whenever we are executing child class the following sequence of events will be executed automatically as a part of static control flow.
		1. Identification of static members from parent to child.
		2. Execution of static variable assignment and static blocks from parent to child.
		3. Execution of only child class main method.

		Example:
			class Base {
				static int i = 10;
				static {
					m1();
					System.out.println("Base Static Block");
				}
				public static void main(String[] args) {
					m1();
					System.out.println("Base main");
				}
				public static void m1() {
					System.out.println(j);
				}
				static int j = 20;
			}

			class Derived extends Base {
				static int x = 100;
				static {
					m2();
					System.out.println("Derived First Static Block");
				}
				public static void main(String[] args) {
					m2();
					System.out.println("Derived main");
				}
				public static void m2() {
					System.out.println(y);
				}
				static {
					System.out.println("Derived Second Static Block");
				}
				static int y = 200;
			}

		Output: java Derived
			0
			Base Static Block
			0
			Derived First Static Block
			Derived Second Static Block
			200
			Derived main

		Output: java Base
			0
			Base Static Block
			20
			Base main

		Note:
			Whenever we are loading child class automatically parent class will be loaded. Whenever we are loading parent class child class won't
			be loaded (because parent class member by default available to the child class where as child class members by default won't available
			to the parent).

11. Instance Control Flow:
		Whenever we are executing a java class first static control flow will be executed. In the static control flow if we are creating ans object
		the follow sequence of events will be executed as a part of instance control flow.
		1. Identification of instance member from top to bottom.
		2. Execution of instance variable assignment and instance blocks from top to bottom.
		3. Execution of constructor.

		Example 1:
			class Test {
				int i = 10;
				{
					m1();
					System.out.println("First Instance Block");
				}
				Test() {
					System.out.println("Constructor");
				}
				public static void main(String[] args) {
					Test t = new Test();
					System.out.println("main");
				}
				public void m1() {
					System.out.println(j);
				}
				{
					System.out.println("Second Instance Block");
				}
				int j = 20;
			}
		Output: 0
			First Instance Block
			Second Instance Block
			Constructor
			main
		if we'll commented or remove below line then Output: main
		Test t = new Test();

	Note:
		Static control flow is one time activity which will be performed at the time of class loading.
		But instance control flow is not one time activity and it'll be performed for every object creation.

		Object creation is the most costly operation if there is no specific requirement then it's not recommended to create object.

	Instance control float in parent to child relationship:
		Whenever we are creating child class object the following sequence of events will be performed automatically. As a part of instance control
		flow.
		1. Identification of instance member from parent to child (4-14).
		2. Execution of instance variable assignments and instance blocks only in parent class (15-19).
		3. Execution of parent constructor (20).
		4. Execution of instance variable assignments and instance blocks in child class (21-26).
		5. Execution of child constructor (27).

		Example 2:
			class Parent {
				int i = 10;
				{
					m1();
					System.out.println("Parent Instance Block");
				}
				Parent() {
					System.out.println("Parent Constructor");
				}
				public static void main(String[] args) {
					Parent p = new Parent();
					System.out.println("Parent main");
				}
				public void m1() {
					System.out.println(j);
				}
				int j = 10;
			}
			class Child extends Parent {
				int x = 100;
				{
					m2();
					System.out.println("Child First Instance Block");
				}
				Child() {
					System.out.println("Child Constructor");
				}
				public static void main(String[] args) {
					Child c = new Child();
					System.out.println("Child main");

				}
				public void m2() {
					System.out.println(y);
				}
				{
					System.out.println("Child Second Instance Block");
				}
				int y = 20;
			}
		Output: 0
			Parent Instance Block
			Parent Constructor
			0
			Child First Instance Block
			Child Second Instance Block
			Child Constructor
			Child main

		Example 3:
			class Test {
				{
					System.out.println("FIB");
				}
				static {
					System.out.println("FSB");
				}
				Test() {
					System.out.println("Constructor");
				}
				public static void main(String[] args) {
					Test t1 = new Test();
					System.out.println("main");
					Test t2 = new Test();
				}
				static {
					System.out.println("SSB");
				}
				{
					System.out.println("SIB");
				}
			}
		Output: FSB
			SSB
			FIB
			SIB
			Constructor
			main
			FIB
			SIB
			Constructor

		Example 4:
			public class Initialization {
				private static String m1(String msg) {
					System.out.println(msg);
					return msg;
				}
				public Initialization() {
					m = m1("1");
				}
				{
					m = m1("2");
				}
				String m = m1("3");
				public static void main(String[] args) {
					Object o = new Initialization();
				}
			}
		Output: 2
			3
			1

		Example 5:
			public class Initialization2 {
				private static String m1(String msg) {
					System.out.println(msg);
					return msg;
				}
				static String m = m1("1");
				{
					m = m1("2");
				}
				static {
					m = m1("3");
				}
				public static void main(String[] args) {
					Object o = new Initialization2();
				}
			}
		Output: 1
			3
			2

	Note:
		From static area we can't access instance members direct because while executing static area JVM may not identify instance members.
		Example:
			class Test {
				int x = 10;
				public static void main(String[] args) {
					System.out.println(x);			// CTE -> error: non-static variable x cannot be referenced from a static context
				}
			}

		Example:
			class Test {
				int x = 10;
				public static void main(String[] args) {
					Test t = new Test();
					System.out.println(t.x);		// Output: 10
				}
			}

	Q. In how many ways we can create an object in java or In how many ways we can get object in java?
	Ans. There are 5 standard ways to create an object in java.
		1. By using new operator:
			Test t = new Test();

		2. By using newInstance() method:
			Test t = (Test)Class.forName("Test").newInstance();

		3. By using Factory method:
			Runtime r = Runtime.getRuntime();
			DateFormat df = DateFormat.getInstance();

		4. By using Clone() method:
			Test t1 = new Test();
			Test t2 = (Test) t1.clone();

		5. By  using Deserialization:
			FileInputStream fis = new FileInputStream("abc.src");
			ObjectInputStream ois = new ObjectInputStream(fis);
			Dog d2 = (Dog)ois.readObject();

12. Constructor:
		Once we creates an object compulsory we should perform initialization then only the object in a position to respond properly.
		Whenever we are creating an object some piece of the code will be executed automatically to perform initialization of the object. This piece
		of the code is nothing but constructor. Hence the main purpose of constructor is to perform initialization of an object.
		Example 1:
			class Student {
				String name;
				int rollNo;
				Student(String name, int rollNo) {
					this.name = name;
					this.rollNo = rollNo;
				}
				public static void main(String[] args) {
					Student s1 = new Student("Test1", 101);
					Student s2 = new Student("Test2", 102);
				}
			}

		Note:
			The main purpose of constructor is to perform initialization of an object but not to create object.

		Difference between Constructor And Instance block:
			The main purpose of constructor is to perform initialization of an object.
			But other than initialization if we want to perform any activity for every object creation then we should go for instance block (like
			updating one entry in DB for every object creation or incrementing count valur for every object creation etc).

			Both constructor & instance block have their own different purposes and replacing one concept with another concept may not work always.

			Both constructor & instance block will be executed for every object creation but instance block first followed by constructor.

			Demo program to print no of object created for a class.

			Example 2:
				class Test {
					static int count = 0;
					{
						count++;
					}
					Test() {}
					Test(int i) {}
					Test(double d) {}
					public static void main(String[] args) {
						Test t1 = new Test();
						Test t2 = new Test(10);
						Test t3 = new Test(10.5);
						System.out.println("The no of object created: " + count);
					}
				}
			Output: The no of object created: 3

	Rules of writing constructors:
		1. Name of the class & name of the constructor must be matched.
		2. Return type concept not applicable for constructor. Even void also.
		By mistake if we are trying to declare return type for the constructor then we won't get any CTE because compiler treats it as a method.
		Example:
			class Test {
				void Test() {}
			}
		Hence it's legal but stupid to have a method how's name is exactly same as class name.
			class Test {
				void Test() {
					System.out.println("method but not constructor");
				}
				public static void main(String[] args) {
					Test t = new Test();
					t.Test();
				}
			}
		The only applicable modifier for constructors are:
			1. public
			2. private
			3. protected
			4. default

		If we are trying to use any other modifier we'll get CTE.
			class Test {
				static Test() {							// error: modifier static not allowed here
					System.out.println("method but not constructor");
				}
			}

	default constructor:
		Compiler is responsible to generate default constructor (but not JVM).
		If we are not writing any constructor then only compiler will generate default constructor. That's if we are writing at least one constructor
		then compiler won't generate default constructor. Hence every class in java can contain constructor it may be default constructor generated
		by compiler or customized constructor explicitly provided by programmer. But not both simultaneously.

	Prototype of default constructor:
		1. It's always no-arg constructor.
		2. The access modifier of default constructor is exactly same as access modifier of class (this rule is applicable only for public & default).
		3. It contains only one line super(). It's a no argument call to super class constructor.
________________________________________________________________________________________
		P's Code		| 			C's Code		|
----------------------------------------|-----------------------------------------------|
class Test {}				| class Test {Test(){super();}}			|
public class Test {}			| public class Test {Test(){super();}}		|
class Test {void Test(){}}		| class Test {Test(){super();}void Test(){}}	|
----------------------------------------|-----------------------------------------------|
class Test {Test(){}}			| class Test {Test(){super();}}			|
class Test {Test(){super();}}		| class Test {Test(){super();}}			|
----------------------------------------|-----------------------------------------------|
Programmer's generated code:
	class Test {Test(){this(10);}Test(int i){}}

Compiler's generated code:
	class Test {Test(){this(10);}Test(int i){super();}}

		The first line inside every constructor should be either super or this. and if we are not writing anything then compiler will always placed
		super();

	Case 1:
		We can super() or this() only in first line of constructor. If we are trying to take anywhere else we'll get compile time error.
		Example:
			class Test {
				Test() {
					System.out.println("constructor");
					super();	// CTE -> error: call to super must be first statement in constructor
				}
			}
	Case 2:
		Within the constructor we can take either super() or this(). But not both simultaneously.
		Example:
			class Test {
				Test() {
					super();
					this();		// CTE -> error: call to this must be first statement in constructor
				}
			}

	Case 3:
		We can use super() or this() only inside constructor. If we are trying to use outside of constructor we'll get CTE.
		Example:
			class Test {
				public void m1() {
					super();	// CTE -> error: call to super must be first statement in constructor
					System.out.println("Hello");
				}
			}

		That's we can call a constructor directly from another constructor only

	super() or this():
		We can use only in constructor.
		Only in first line.
		Only one but not both simultaneously.

________________________________________________________________________________________________________
	super(), this()					|		super, this			|
--------------------------------------------------------|-----------------------------------------------|
1. These are constructor call's to call super 		|1. These are keyword to refer super class &	|
 class & current class constructor.			| current class instance member.		|
2. We can use only in constructor as first line.	|2. We can use anywhere except static area.	|
3. We can use only once in constructor.			|3. We can use any no of times.			|
--------------------------------------------------------|-----------------------------------------------|

	Example:
		class Test {
			public static void main(String[] args) {
				System.out.println(super.hashCode());	// CTE -> error: non-static variable super cannot be referenced from a static context
			}
		}

	Example:
		class P {
			int x = 100;
		}
		class C extends P {
			int x = 200;
			public void m1() {
				System.out.println("Current class instance variable: " + this.x);
				System.out.println("Parent class instance variable: " + super.x);
			}
		}
		class Test {
			public static void main(String[] args) {
				C c = new C();
				c.m1();
			}
		}

	Overloaded Constructors:
		Within a class we can declare multiple constructors. and all these constructors having same name but different type of arguments. Hence
		all these constructors are consider as Overloaded constructors. Hence Overloading concept applicable for constructors.
		Example 1:
			class Test {
				Test() {
					this(10);
					System.out.println("no-arg");
				}
				Test(int i) {
					this(10.5);
					System.out.println("int-arg");
				}
				Test(double d) {
					System.out.println("double-arg");
				}
				public static void main(String[] args) {
					Test t = new Test();
					Test t1 = new Test(10);
					Test t2 = new Test(10.5);
					Test t4 = new Test(10l);
				}
			}
		Output:	double-arg
			int-arg
			no-arg
			double-arg
			int-arg
			double-arg
			double-arg

		For constructor, inheritance & overriding concepts are not applicable. But overloading concept is applicable.

		Every class in java including abstract class can contain constructor. But interface can't contain constructor.
		class Test {
			Test(){}
		}

		abstract class Test {
			Test(){}
		}

		interface Test {
			Test(){}	// Invalid
		}

		Case 1:
			Recursive method call is a RTE is saying StackOverflowError.
			But in our program if there is a chance of recursive constructor invocation then the code won't compile and we'll get CTE.

			Example:
				class Test {
					public static void m1() {
						m2();
					}
					public static void m2() {
						m1();
					}
					public static void main(String[] args) {
						m1();
						System.out.println("Hello");
					}
				}
			Output: RTE -> StackOverflowError

			Example:
				class Test {
					Test() {		// CTE -> error: recursive constructor invocation
						this(10);
					}
					Test(int i) {
						this();
					}
					public static void main(String[] args) {
						System.out.println("Hello");
					}
				}

		Case 2:
			class P {}		// P(){super();} - compiler provided
			class C extends P {}	// C(){super();} - compiler provided

			class P {
				P() {}		// super(); - compiler provided
			}
			class C extends P {}	// C(){super();} - compiler provided

			class P {
				P(int i) {}	// super();	-	compiler provided
			}
			class C extends P {}	// C(){super();} - compiler provided, but no-arg constructor not found in parent so throwing below CTE
						// CTE -> error: constructor P in class P cannot be applied to given types;

			Note:
				1. If parent class contains any argument constructor then while writing child classes we have to take special wrt constructors.
				*2. Whenever we are writing any argument constructor it's highly recommended to write no-arg constructor also.

		Case 3:
			import java.io.IOException;
			class P {
				P() throws IOException {}
			}
			class C extends P {}		// C(){super();} - compiler provided, CTE -> error: unreported exception IOException in default constructor

			import java.io.IOException;
			class P {
				P() throws IOException {}
			}
			class C extends P {
				C() throws IOException, Exception, Throwable {
					super();
				}
			}

			Note:
				If parent class constructor throws any checked exception compulsory child class constructor should throw same checked exception
				or it's parent otherwise the code won't compile.

		Q. Which of the following is valid?
		1. The main purpose of constructor is to create an object. // Invalid
		2. The main purpose of constructor is to perform initialization of an object.	// Valid
		3. The name of the constructor need not be same as class name.	// Invalid
		4. Return type concept applicable for constructor but only void.	// Invalid
		5. We can apply any modifier for constructor. // Invalid
		6. Default constructor generated by JVM.	// Invalid
		7. Compiler is responsible to generate default constructor. // Valid
		8. Compiler will always generates default constructor. // Invalid
		9. If we are not writing no-arg constructor then compiler will generate default constructor. // Invalid
		10. Every no-arg constructor is always default constructor. // Invalid
		11. Default constructor is always no-arg constructor. // Valid
		12. The first line inside every constructor should be either super() or this(). If we are not writing any thing then compiler will generates
			this. // Invalid
		13. For constructors both overloading & overriding concept is applicable. // Invalid
		14. For constructors inheritance concept applicable but not overriding.		// Invalid
		15. Only concrete classes can contain constructor but abstract classes can't. // Invalid
		16. Interface can contain constructor. // Invalid
		17. Recursive constructor invocation is a runtime exception. // Invalid
		18. If parent class constructor throws some checked exception then compulsory child class should throw the same checked exception or
			it's child. // Invalid

	Singleton classes:
		For any java class if we are allow to create only one object. Such type of class is called singleton class.
		Example:
			Runtime, BusinessDelegate, ServiceLocator
		
		Advantage of singleton class:
			If several people have same requirement then it's not recommended to create a separate object for every requirement. we have to create
			only one object and we can use same object for every similar requirement. So that performance & memory utilization's will be improved.
			This is the central idea of singleton classes.
			
			Example:
				Runtime r1 = Runtime.getRuntime();
				Runtime r2 = Runtime.getRuntime();
				Runtime r3 = Runtime.getRuntime();
				.
				.
				.
				Runtime r1lakh = Runtime.getRuntime();
		
		Q. How to create our own singleton classes?
		Ans. We can create our own singleton classes for this we have to use private constructor and private static variable and public factory
			method.
			Approach 1:
				class Test {
					private static Test t = new Test();
					private Test() {
						
					}
					public static Test getInstance() {
						return t;
					}
				}				
				
				class Singleton {
					public static void main(String[] args) {
						Test s1 = Test.getInstance();
						Test s2 = Test.getInstance();
						System.out.println(s1.hashCode());
						System.out.println(s2.hashCode());
						System.out.println(s1== s2);
						System.out.println(s1.equals(s2));
					}
				}
				
		Note:
			Runtime class is internally implemented by using this approach.
			
			Approach 2:
				class Test {
					private static Test t = null;
					private Test() {
						
					}
					public static Test getInstance() {
						if(t == null) {
							t = new Test();
						}
						return t;
					}
				}
			
			At any point of time for test class we can create only one object. Hence Test class is singleton class.
			
		Q. Class is not final but we are not allowed to create child classes. How it's possible?
		Ans. By declaring every constructor as private, We can restrict child class creation.
		class P {
			private P() {}
		}

		class C extends P {} // error: P() has private access in P
		
		for the above class it's impossible to create child class.
