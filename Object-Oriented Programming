1. Data Hiding:
	Out side person can't access our internal data directly or our data should not go out directly. This OOP feature is nothing but data hiding.
	After validation/authentication out side person can access our internal data.
	Example 1:
		After providing proper userName/password we can able to access our gmail inbox information.

	Example 2:
		Even tho we are valid customer of the bank we can able to access our account information and we can't access others account information.

	By declaring data member (variable) as private we can achieve data hiding
	Example:
		public class Account {
			private double balance;
			public double getBalance() {
				// Validation
				return balance;
			}
		}

	The main advantage of data hiding is security.

	Note: It's highly recommended to declare data member (variable) as private.

2. Abstraction:
	Hiding internal implementation and just highlight the set of services what we are offering is the concept of abstraction.
	Example:
		Through bank ATM GUI screen bank people are highlighting the set of services what they are offering without highlighting internal
		implementation.

	The main advantages of abstraction are
		1. We can achieve security because we are not highlighting our internal implementation.
		2. Without affecting outside person we can able to perform any type of changes in our internal system. Enhancement will become easy.
		3. It improves maintainability of the application.
		4. It improves easiness to use our system.

	By using interfaces and abstract classes we can implement abstraction.

3. Encapsulation:
	The process of binding data & corresponding methods into a single unit is nothing but encapsulation.
	Example:
		class Student {
			data member + methods (behaviour)
		}

	If any component follows the data hiding & abstraction such type of component is said to be encapsulated component.
	Encapsulation = data hiding + abstraction

	Example:
		public class Account {
			private double balance;
			public double getBalance() {
				// Validation
				return balance;
			}
			public void setBalance(double balance) {
				// Validation
				this.balance = balance;
			}
		}

		GUI -> Balance Enquiry, Update Balance

	The main advantages of encapsulation are
	1. We can achieve security
	2. Enhancement will become easy
	3. It improves maintainability of the application

	The main advantage of encapsulation is we can achieve security but the main disadvantage of encapsulation is it increases length of the code
	and slows down execution.

4. Tightly Encapsulated Class:
	A class is said to be tightly encapsulated if and only if each and every variable declare as private. Whether class contains corresponding getter
	& setter methods or not. and whether these methods are declared as public or not. These things we are not required to check.
	Example:
		public class Account {
			private double balance;
			public double getBalance() {
				return balance;
			}
		}

	Q. Which of the following are tightly encapsulated?
	class A {
		private int x = 10;			// Yes
	}
	class B extends A {
		int y = 20;					// No
	}
	class C extends A {
		private int z = 30;			// Yes
	}

	Q. Which of the following classes are tightly encapsulated?
	class A {
		int x = 10;					// No
	}
	class B extends A {
		private int y = 20;			// No
	}
	class C extends B {
		private int z = 30;			// No
	}

	Note: If the parent class is not tightly encapsulated then no child class is tightly encapsulated.

5. Is-A Relationship:
	It's a also know as inheritance.
	That main advantage of Is-A relationship is code reusability.
	By using extends keyword we can implement Is-A relationship.

	Example:
		class P {
			public void m1() {
				System.out.println("Parent");
			}
		}
		class C extends P {
			public void m2() {
				System.out.println("Child");
			}
		}
		class Test {
			public static void main(String[] args) {
				P p = new P();
				p.m1();			// Output: Parent
				p.m2();			// CTE -> error: cannot find symbol

				C c = new C();
				c.m1();			// Output: Parent
				c.m2();			// Output: Child

				P p1 = new C();
				p1.m1();		// Output: Parent
				p1.m2();		// CTE -> error: cannot find symbol

				C c1 = new P();	// CTE -> error: incompatible types: P cannot be converted to C
			}
		}

	Conclusion:
		1. What ever method parent has by default to the child. Hence child reference we can call parent and child class method.
		2. What ever methods child has by default not available to parent. Hence on the parent reference we can't call child specific methods.
		3. Parent reference can be used to hold child object but by using that reference we can't call child specific methods but we can call the
		methods present in parent class.
		4. Parent reference can be used to hold child object but child reference can't be used to hold parent object.

		Example:
			Without Inheritance
			class VLone {
				300 Methods;
			}
			class HLone {
				300 Methods;
			}
			class PLone {
				300 Methods;
			}

			With Inheritance
			class Loan {
				250 Common Methods;
			}
			class VLoan extends Loan {
				50 Specific Methods;
			}
			class HLone extends Loan {
				50 Specific Methods;
			}
			class PLoan extends Loan {
				50 Specific Methods;
			}

		Note: The most common methods which are applicable for any type of child, we have to define in parent class. The specific methods which are
		applicable for a particular child we have to define in child class.

	Total Java API is implemented based on inheritance concept.
	The most common methods which are applicable for any java object are defined in object class. Hence every class in java ia the child class of
	object either directly or indirectly. So that object class method by default available to every java class without rewriting. Due to this object
	class access root for all java classes.

	Throwable class defines the most common methods which are required for every exception & error classes. Hence this class access root for java
	exception hierarchy.

	Multiple inheritance:
		A java class can't extend more than one class at a time. Hence java won't provide support for multiple inheritance in classes.
		Example:
			class A extends B, C {} // CTE

	Note: If our class doesn't extend any other class then only our class is direct child class of object.
		Example:
			class A {} // A is a child of object

		If our class extend any other class then our class is indirect child class of object

			class B extends A {} // B is child of object of class A and A is child of Object class
			it's multi level inheritance but not multiple inheritance.

		Either directly or indirectly java won't provide support for inheritance wrt classes.

	Why java won't provide support for multiple inheritance?
	There may be a chance of ambiguity problem hence java won't provide support for multiple inheritance.
	class C extends P1, P2

	But interface can extend any no of interfaces simultaneously. Hence java provide support for multiple inheritance wrt interfaces.
	Example:
		interface A {}
		interface B {}
		interface C extends A, B {}

	Why ambiguity problem won't be there in interfaces:
		P1I1 -> m1(), P2I2 -> m1()
		CI -> m1()
		class c implements CI, P1I1, P2I2 {
			m1() {}
		}

	Even tho multiple method declarations are available but implementation is unique. Hence there is no chance of ambiguity problem in interfaces

	Note: Strictly speaking through interfaces we won't get any inheritance.

	Cyclic inheritance:
		Cyclic inheritance is not allowed in java. Of course it's not required
		Example:
			class A extends A {}	// CTE -> cyclic inheritance involving A

			class A extends B {}	// CTE -> cyclic inheritance involving A
			class B extends A {}

6. Has-A Relationship:
	Has-A relationship is also known as composition or aggregation.
	There is no specific keyword to implement Has-A a relation but most of the time we are depending on new keyword.
	The main advantage of Has-A relationship is reusability of the code.
	Example:
		class Engine {
			// Engine specific functionality
		}

		class Car {
			Engine e = new Engine()
		}
		Car Has-A a Engine reference

	Difference between composition & aggregation:
		Composition:
			Without existing container object if there is no chance of existing contented object then container & contented objects are strongly
			associated and this strong association is nothing but composition.

			Example:
				University consist of several departments without existing university there is no chance of existing department. Hence university
				and	department are strongly associated and this strong association is nothing but composition.

		Aggregation:
			Without existing container object if there is a chance of existing contented object then container & contented objects are weekly
			associated and this week association is nothing but aggregation.

			Example:
				Department consist of several professors. Without existing department there may be chance of existing professors objects. Hence
				department and professors objects are weekly associated and this week association is nothing but aggregation.

	Note:
		In composition objects are strongly associated where as in aggregation objects are weekly associated.
		In composition container object holds directly contented objects where as in aggregation container object holds just references of contented
		objects.

	Is-A vs Has-A:
		If we want total functionality of a class automatically then we should go for Is-A relationship.
		Example:
			Person - Student : Complete functionality required of person in student

		If we want part of the functionality then we should go for Has-A relationship.
		Example:
			class Test {100 method}
			class Demo {
				Test t = new Test();
				t.m1();
				t.m6();
				t.m99();
			}

7. Method Signature:
	In java method signature consist of method names followed by argument types.
	Example:
		public static int m1(int i, float f);

		m1(int, float): method signature

	Return type is not part of method signature is java.
	Compiler will use method signature to resolve method calls.
	Example:
		class Test {
			public void m1(int i) {}
			public void m2(String s) {}
			public static void main(String[] args) {
				Test t = new Test();
				t.m1(10);
				t.m2("Hello");
				t.m3(10.5);			// CTE -> error: cannot find symbol. symbol:   method m3(double), location: variable t of type Test
			}
		}

	Within a class two method with the same signature not allowed.
	Example:
		class Test {
			public void m1(int i) {}
			public int m1(int x) {		// CTE -> error: method m1(int) is already defined in class Test
				return 10;
			}
			public static void main(String[] args) {
				Test t = new Test();
				t.m1(10);
				t.m1(10);
			}
		}

8. Overloading:
	Two method said to be overloaded if and only if both methods having same name but different argument types.

	In C language method overloading concept is not available. Hence we can't declare multiple methods with the same name but different argument
	types. If there is a change in argument type compulsory we should go for new method name. Which increases complexity of programming.

	But in java we can declare multiple methods with same name but different argument types. Such type of methods are called overloaded method.
	Example:
		abs(int i), abs(long l), abs(float f)

	Having overloading concept in java reduces complexity of programming.
	Example:
		class Test {
			public void m1() {
				System.out.println("No-Arg method");
			}
			public void m1(int x) {
				System.out.println("int-Arg method");
			}
			public void m1(double d) {
				System.out.println("double-Arg method");
			}
			public static void main(String[] args) {
				Test t = new Test();
				t.m1();				// Output: No-Arg method
				t.m1(10);			// Output: int-Arg method
				t.m1(10.5);			// Output: double-Arg method
			}
		}

	* In overloading method resolution always takes care by compiler based on reference type. Hence overloading is also consider as compile time
		polymorphism, static binding, early binding.

	Case 1:
		Automatic promotion in overloading
			1. while resolving overloaded methods if exact matched method is not available then we won't get any compile time error immediately.
			First it'll promote argument to the next level and check where matched method is available or not. If matched method is available then
			it'll be considered. If matched method is not available then compiler promote argument once again to the next level. This process will
			be continued until all possible promotions. Still if the matched method is not available then we'll get CTE.
			The following are all possible promotions in overloading.
			Example:
				byte - short - int - long - float - double
				char - int - long - float - double

			This process is called automatic promotion in overloading.

			class Test {
				public void m1(int x) {
					System.out.println("int-Arg method");
				}
				public void m1(float f) {
					System.out.println("float-Arg method");
				}
				public static void main(String[] args) {
					Test t = new Test();
					t.m1(10);		// Output: int-Arg method
					t.m1(10.5f);	// Output: float-Arg method
					t.m1('a');		// Output: int-Arg method
					t.m1(10l);		// Output: float-Arg method
					t.m1(10.5);		// CTE -> error: no suitable method found for m1(double)
				}
			}

	Case 2:
		class Test {
			public void m1(String s) {
				System.out.println("String version");
			}
			public void m1(Object o) {
				System.out.println("Object version");
			}
			public static void main(String[] args) {
				Test t = new Test();
				t.m1(new Object());		// Output: Object version
				t.m1("Test");			// Output: String version
				t.m1(null);				// Output: String version
			}
		}

		While resolving overloaded method compiler will always gives the precedence to child type argument when compared with parent type argument.

	Case 3:
		class Test {
			public void m1(String s) {
				System.out.println("String version");
			}
			public void m1(StringBuffer sb) {
				System.out.println("StringBuffer version");
			}
			public static void main(String[] args) {
				Test t = new Test();
				t.m1("Test");						// Output: String version
				t.m1(new StringBuffer("Test"));		// Output: StringBuffer version
				t.m1(null);							// Output: CTE -> error: reference to m1 is ambiguous
			}
		}

	Case 4:
		class Test {
			public void m1(int i, float f) {
				System.out.println("int-float version");
			}
			public void m1(float f, int i) {
				System.out.println("float-int version");
			}
			public static void main(String[] args) {
				Test t = new Test();
				t.m1(10, 10.5f);	// Output: int-float version
				t.m1(10.5f, 10);	// Output: float-int version
				t.m1(10, 10);		// Output: error: reference to m1 is ambiguous
				t.m1(10.5f, 10.5f);	// Output: error: no suitable method found for m1(float,float)
			}
		}

	Case 5:
		class Test {
			public void m1(int i) {
				System.out.println("General Method");
			}
			public void m1(int... i) {
				System.out.println("Var-Args Method");
			}
			public static void main(String[] args) {
				Test t = new Test();
				t.m1();			// Output: Var-Args Method
				t.m1(10, 20);	// Output: Var-Args Method
				t.m1(10);		// Output: General Method
			}
		}

		In general Var-Args method will get least priority. That's if no other method matched then only Var-Args method will get the chance. It's
		exactly same as default case inside switch.

	Case 6:
		class Animal {}
		class Monkey extends Animal {}

		class Test {
			public void m1(Animal a) {
				System.out.println("Animal version");
			}
			public void m1(Monkey m) {
				System.out.println("Monkey version");
			}
			public static void main(String[] args) {
				Test t = new Test();
				Animal a = new Animal();
				t.m1(a);								// Output: Animal version
				Monkey m = new Monkey();
				t.m1(m);								// Output: Monkey version
				Animal a1 = new Monkey();
				t.m1(a1);								// Output: Animal version
			}
		}

		Note:
			In overloading method resolution always takes care by compiler based on reference type.
			In overloading runtime object won't play any role.

9. Overriding:
	Whatever methods parent has by default available to the child through inheritance. If child class not satisfied with parent class implementation
	then child is allowed to redefine that method based on it's requirement. This process is called Overriding.
	The parent class method which is overridden is called overridden method and child class method which is overriding is called Overriding method.
	Example:
		class P {
			public void property() {
				System.out.println("Cash + Land + Gold");
			}
			public void marry() {
				System.out.println("Laxmi");
			}
		}
		class C extends P {
			public void marry() {
				System.out.println("3Sha|4Me|9Tara");
			}
		}
		class Test {
			public static void main(String[] args) {
				Test t = new Test();
				P p = new P();
				p.marry();			// Output: Laxmi
				C c = new C();
				c.marry();			// Output: 3Sha|4Me|9Tara
				P p1 = new C();
				p1.marry();			// Output: 3Sha|4Me|9Tara
			}
		}

	* In Overriding method resolution always takes care by JVM based on runtime object and hence overriding is also considered as runtime
	polymorphism or dynamic polymorphism or late binding.

	Rules for Overriding:
		1. In Overriding, methods name & argument types must be matched that's method signatures must be same.

		2. In Overriding, return type must be same but this rule is applicable only until 1.4 version only. From 1.5 version onwards we can take
			Co-Variant types. According to this child class method return type need not be same as parent method return type. It's child type also
			allowed.
			Example:
				class P {
					public Object m1() {
						return null;
					}
				}
				class C extends P {
					public String m1() {
						return null;
					}
				}

			It's invalid in 1.4 version but from 1.5 version it's valid.

			Parent class method return type:	Object						Number			String		double

			Child class method return type: 	Object|String|StringBuffer	Number|Integer	String		int - not possible - CTE

			Co-Variant return type concept applicable only fro Object types but not for primitive types

		3. Parent class private methods not available to the child. Hence Overriding concept not applicable for private methods.
			Based on our requirement we can define exactly same private method in child class it's valid but not overriding.
			Example:
				class P {
					private void m1() {}
				}
				class C extends P {
					private void m1() {}	// It's valid but not overriding
				}

		4. We can't override parent class final method in child class. If we are trying to override we'll get CTE.
			Example:
				class P {
					public final void m1() {}	// CTE -> error: m1() in C cannot override m1() in P
				}
				class C extends P {
					public void m1() {}
				}

		5. Parent class abstract method we should override in child class to provide implementation.
			Example:
				abstract class P {
					public abstract void m1();
				}
				class C extends P {
					public abstract void m1() {}
				}

		6. We can override non-abstract method as abstract.
			Example:
				class P {
					public void m1(){}
				}
				abstract class C extends P {
					public abstract void m1();
				}

			The main advantage of this approach is we can stop the availability of parent method implementation to the next level child classes.

		7. In overriding the following modifiers won't keep any restriction.
			1. synchronized
			2. native
			3. strictfp
			4. abstract

		parent method	final			non-final	abstract		synchronized		native			strictfp
						not				possible	both possible	both possible		both possible	both possible
		child method  	non-final		final		non-abstract	non-synchronized	non-native		non-strictfp

		8. While overriding we can't reduce scope of access modifier. But we can increase the scope.
			Example:
				class P {
					public void m1(){}
				}
				class C extends P {
					void m1() {}		// CTE -> error: m1() in C cannot override m1() in P
										// attempting to assign weaker access privileges; was public
				}

				class P {
					void m1(){}
				}
				class C extends P {
					public void m1() {}	// possible
				}

		private < default < protected < public
	Parent class method:	public		protected				default							private

	Child class method :	public		protected|public		default|protected|public		overloading concept not applicable for private

		9. If child class method throws any checked exception compulsory parent class method should throw the same checked exception or it's parent
		otherwise we'll get CTE. But there are no restriction for unchecked exception.
		Example:
			import java.io.*;
			class P {
				public void m1() throws IOException {}
			}
			class C extends P {
				public void m1() throws EOFException, InterruptedException {}
			}
		CTE  -> error: m1() in C cannot override m1() in P, overridden method does not throw java.lang.InterruptedException

	Which of the followings are valid

	1.
		P: public void m1() throws Exception
		C: public void m1()

	2.
		P: public void m1()
		C: public void m1() throws Exception

	3.
		P: public void m1() throws Exception
		C: public void m1() throws IOException

	4.
		P: public void m1() throws IOException
		C: public void m1() throws Exception

	5.
		P: public void m1() throws IOException
		C: public void m1() throws FileNotFoundException, EOFException

	6.
		P: public void m1() throws IOException
		C: public void m1() throws EOFException, InterruptedException

	7.
		P: public void m1() throws IOException
		C: public void m1() throws ArithmeticException, NullPointerException, ClassCastException

	Ans.
		1. Valid
		2. Invalid
		3. Valid
		4. Invalid
		5. Valid
		6. Invalid
		7. Valid

	import java.io.IOException;
	class P {
		public void m1() throws IOException {}
	}
	class C extends P {
		public void m1() throws IOException {}
	}
	class Test {
		public static void main(String[] args) {
			try {
				P p = new C();
				p.m1();
			} catch(IOException e) {
				e.printStackTrace();
			}

		}
	}
	valid

	Overriding WRT static methods:
		We can't override a static method as non-static otherwise we'll get CTE.
		Example:
			class P {
				public static void m1() {}
			}
			class C extends P {
				public void m1() {}			// CTE ->  error: m1() in C cannot override m1() in P, overridden method is static
			}

			class P {
				public void m1() {}
			}
			class C extends P {
				public static void m1() {}	// CTE -> error: m1() in C cannot override m1() in P, overriding method is static
			}

		If both Parent and Child class methods are static then we won't get any CTE. It seams overriding concept applicable for static methods.
		But it's not overriding and it' s method hiding.
		Example:
			class P {
				public static void m1() {}
			}
			class C extends P {
				public static void m1() {}
			}

	Method Hiding:
		All rules of method hiding is exactly same as overriding except the following differences
		Example:
			class P {
				public static void m1() {
					System.out.println("Parent");
				}
			}
			class C extends P {
				public static void m1() {
					System.out.println("Child");
				}
			}
			class Test {
				public static void main(String[] args) {
					P p = new P();
					p.m1();				// Output: Parent
					C c = new C();
					c.m1();				// Output: Child
					P p1 = new C();
					p1.m1();			// Output: Parent
				}
			}
________________________________________________________________________________________________________________________________________________________
			Method Hiding					|				Overriding					|
------------------------------------------------------------------------|-------------------------------------------------------------------------------|
1. Both Parent and Child class method should be static.			|1. Both Parent and Child class method should be non-static.			|
2. Compiler is responsible for method resolution based of reference	|2. JVM is always responsible for method resolution based of runtime object.	|
 type.									|										|
3. It's also known as Compile time Polymorphism, Static Polymorphism,	|3. It's also known as Runtime Polymorphism, Dynamic Polymorphism, Late	Binding.|
 Early Binding.								|										|
--------------------------------------------------------------------------------------------------------------------------------------------------------|

	Overriding WRT Var-Args Methods:
		We can override Var-Args method with another Var-Args method only. If we are trying to override with normal method then it'll become
		overloading but not overriding.
		Example: Overloading
			class P {
				public void m1(int... x) {
					System.out.println("Parent");
				}
			}
			class C extends P {
				public void m1(int x) {
					System.out.println("Child");
				}
			}
			class Test {
				public static void main(String[] args) {
					P p = new P();
					p.m1(10);				// Output: Parent
					C c = new C();
					c.m1(10);				// Output: Child
					P p1 = new C();
					p1.m1(10);				// Output: Parent
				}
			}

		In the above program if we will replace child method with Var-Args method then it'll become overriding. In this case the output is
		Example: Overriding
			class P {
				public void m1(int... x) {
					System.out.println("Parent");
				}
			}
			class C extends P {
				public void m1(int... x) {
					System.out.println("Child");
				}
			}
			class Test {
				public static void main(String[] args) {
					P p = new P();
					p.m1(10);				// Output: Parent
					C c = new C();
					c.m1(10);				// Output: Child
					P p1 = new C();
					p1.m1(10);				// Output: Child
				}
			}
	Overriding WRT variables:
		Variable resolution always takes care by compiler based on reference type irrespective of whether the variable is static or non-static.
		(overriding concept applicable only for method but not for variables).
		Example:
			class P {
				int x = 888;
			}
			class C extends P {
				int x = 999;
			}
			class Test {
				public static void main(String[] args) {
					P p = new P();
					System.out.println(p.x);		// Output: 888
					C c = new C();
					System.out.println(c.x);		// Output: 999
					P p1 = new C();
					System.out.println(p1.x);		// Output: 888
				}
			}
________________________________________________________________________________________________
P	|	non-static	|	static		|	non-static	|	static	|
C	|	non-static	|	non-static	|	static		|	static	|
--------|-----------------------------------------------|-----------------------|---------------|
	|	888		|	888		|	888		|	888	|
	|	999		|	999		|	999		|	999	|
	|	888		|	888		|	888		|	888	|
------------------------------------------------------------------------------------------------|

Difference between Overloading and Overriding:
________________________________________________________________________________________________________________________________________________________
Property			|	Overloading			|		Overriding							|
--------------------------------|---------------------------------------|-------------------------------------------------------------------------------|
1. Method Name			| Must be same.				| Must be same.									|
2. Argument Types		| Must be different (at lease order).	| Must be different (including order).						|
3. Method Signature		| Must be different.			| Must be same.									|
4. Return Types			| No Restriction.			| Must be same until 1.4 but from 1.5 version onwards Co-Variant also allowed.	|
5. private, static, final	| Can be overloaded.			| can't be overridden.								|
6. Access Modifier		| No restriction.			| We can't reduce scope of access modifier but we can increase the scope.	|
7. throws clause		| No restriction.			| If child class method throws any checked exception compulsory parent class	|
				|					| method should throw same or parent but no restriction for unchecked exception.|
8. Method resolution		| Always takes care by compiler 	| Always takes care by JVM based on runtime object.				|
				| based on reference type.		|										|
9. It's also known as		| CTP|SP|Early binding.			| RTP|DP|Late binding.								|
---------------------------------------------------------------------------------------------------------------------------------------------------------
Note:
	In Overloading we have to checked only method names (must be same) and argument types (must be different). We are not required to check
	remaining like return types, access modifier etc.

	In Overriding everything we have to check like method name, argument types, return type, access modifier, throws clause etc.

	Consider the following method in parent class.
		public void m1(int x) throws IOException

	In the child class which of the following method we can take
		1. public void m1(int i)			// Overriding
		2. public static int m1(long l)			// Overloading
		3. public static void m1(int i)			// Overriding Invalid
		4. public void m1(int i) throws Exception	// Overriding Invalid
		5. public static abstract void m1(double d)	// Overloading Illegal combination of modifiers 'abstract' and 'static'

	Polymorphism:
		One name but multiple forms is a concept of Polymorphism.
		Example 1:
			Method name is the same but we can apply for different types of arguments (Method Overloading).
			abs(int)
			abs(long)
			abs(float)

		Example 2:
			Method signature is same but in parent class one type of implementation and in the child class another type of implementation (Overriding)
			class P {
				marry() {}
			}
			class C extends P {
				marry() {}
			}
		Example 3:
			Uses of Parent reference to hold child object is the concept of Polymorphism.
			List l = new ArrayList();
				l = new LinkedList();
				l = new Stack();
				l = new Vector()

		Parent class reference can be used to hold child object but by using that reference we can call only the methods available in parent class.
		And we can't call child specific methods.
		Example:
			P -> m1();
			C -> m2();

			P p = new C();
			p.m1();
			p.m2(); // can't find symbol, symbol method m2(), location: class P

		But by using child reference we can call both parent and child class methods.
			C c = new C();
			c.m1();
			c.m2();

	Q. When we should go for Parent reference to hold Child object?
	Ans. If we don't know exact runtime type of object then we should go for Parent reference.
		for example: the first element present in the ArrayList can be any type. It may be Student object, Customer object, String, StringBuffer.
		Hence the return type of get method is Object, which can hold any object.
		Example: Object o = l.get(0);

________________________________________________________________________________________________________________________________________________________
	C c = new C();							|			P p = new P();						|
	ArrayList al = new ArrayList()					|			List l = new ArrayList()				|
------------------------------------------------------------------------|-------------------------------------------------------------------------------|
1. We can use this approach if we know exact runtime of object.		|1. We can use this approach if we don't know exact runtime type of object.	|
2. By using child reference we can call both parent & child methods	|2. By using parent reference we can call only methods available in parent class|
 (this is the advantage of this approach).				| and we can't call child specific methods (this is the disadvantage of it).	|
3. We can use child reference to hold only particular child class	|3. We can use parent reference to hold any child class object. (this is the	|
 object (this is the disadvantage of this approach).			| advantage of this approach).							|
--------------------------------------------------------------------------------------------------------------------------------------------------------|

	Pillars of OOP
	Encapsulation	-	Security
	Inheritance	- 	Reusability
	Polymorphism	-	Flexibility

					Polymorphism
					    /\
					   /  \
					  /    \
					 /      \
					/	 \
				    Static	Dynamic
				Compile-time 	Runtime
				Early Binding	Late Binding
				     /\			|
		  		    /  \		|
		  		   /    \		|
		 		  /      \		Overriding
				 /        \
			Overloading	Method Hiding

	Beautiful definition of Polymorphism:
		A BOY starts LOVE with the work FRIENDSHIP, but GIRL ends LOVE with the same word FRIENDSHIP. Word is the same but attitude is different.
		This beautiful concept of OOPS is nothing but polymorphism.

13. Coupling:
		The degree of the dependency between the component is call coupling.
		If dependency is more then it's consider as tightly coupling and if dependency is less then it's considered as loosely coupling.

		Example:
			class A {
				static int i = B.j;
			}
			class B {
				static int j = C.k;
			}
			class C {
				static int k = D.m1();
			}
			class D {
				public static int m1() {
					return 10;
				}
			}
			class Test {
				public static void main(String[] args) {
					System.out.println(new A().i);
				}
			}

		The above component said to be tightly coupled with each-other because dependency between the component is more.
		Tightly coupling is not a good programming practice because it has several serious disadvantages.
		1. Without effecting remaining components we can't modify any component. Hence enhancement will become difficult.
		2. It suppresses readability
		3. It reduces maintainability of the application

		Hence we have to maintain dependency between the components as less as possible. That's loosely coupling is good programming practice.

14. Cohesion:
		For every component a clear well define functionality is defined then that component is said to be follow high cohesion.
		low cohesion: every thing define in single unit like TotalServlet hold login, validation, inbox, send, reply, error etc.
		high cohesion: every thing define in a separate module. Best example is MVC. login.jsp, error.jsp, validation.servlet, reply.jsp

		High cohesion is always good programming practice because it has several advantages.
			1. Without affecting remaining components we can modify any component. Hence enhancement will become easy.
			2. It promotes reusability of the code (Where ever validation required we can reuse the same validate servlet without rewriting).
			3. It improves maintainability of the application.

		Note: Loosely coupling & High cohesion are good programming practices.

15. Object Type-Casting:
		We can use parent reference to hold child object.
		Example:
			Object o = new String("Test");

		We can use interface reference to hold implemented class object
		Example:
			Runnable r = new Thread();

		Syntax:
			A b = (C) d;
			A: Class or Interface Name
			b: Nave of reference Name
			C: Class or Interface Name
			d: reference variable name

		Rule:
			1. Compile Time checking:
				The type of 'd' and 'C' must have some relation. Either child to parent or parent to child or same type. Otherwise we'll get CTE
				saying inconvertible types found d type required C

				Example 1:
					Object o = new String("Test");
					StringBuffer sb = (StringBuffer) o;

				Example 2:
					String s = new String("Test");
					StringBuffer sb1 = (StringBuffer) s;	// CTE -> error: incompatible types: String cannot be converted to StringBuffer

			2. Compile Time checking:
				'C' must be either same of derived type of 'A' otherwise we'll get CTE saying incompatible types found C required A.

				Example 1:
					Object o = new String("Test");
					StringBuffer sb = (StringBuffer) o;

				Example 2:
					String s = new String("Test");
					StringBuffer sb1 = (String) s;	// CTE -> error: incompatible types: String cannot be converted to StringBuffer

			3. Runtime Checking:
				Runtime object type 'd' must be either same or derived type of 'C'. Otherwise we'll get RTE saying ClassCastException.

				Example 1:
					Object o = new String("Test");
					StringBuffer sb = (StringBuffer) o; // RTE -> java.lang.ClassCastException: class String cannot be cast to class StringBuffer

				Example 2:
					Object o = new String("Test");
					Object sb = (String) o;				// Valid
